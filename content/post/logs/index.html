---
title: Capture message, warnings and errors from a R function
authors: 
- bangyou-zheng
date: '2020-10-20'
slug: capture-logs
categories:
  - R
tags:
  - R
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<p>During development the web platform <a href="https://phenocopter.bangyou.me">PhenoCopter</a> to process images captured by UAV, I need to capture all logs (i.e. message, warning and error) of R scripts for data processing, and then store into the database which are rendered by web interface and allows user to view all logs in real time.</p>
<div id="define-functions-for-testing" class="section level2">
<h2>Define functions for testing</h2>
<pre class="r"><code>test_message &lt;- function(a){
  message(&quot;this is test from function message.&quot;)
  return(a)
}

test_warning &lt;- function(a){
  warning(&quot;this is test from function warning.&quot;)
  return(a)
}

test_error &lt;- function(a){
  stop(&quot;this is test from function error.&quot;)
  return(a)
}</code></pre>
</div>
<div id="capture-logs-of-a-r-function" class="section level2">
<h2>Capture logs of a R function</h2>
<p>Following the accepted answer from <a href="https://stackoverflow.com/questions/4948361">this question on stackoverflow</a>, a rewrote function is developed to capture <code>error</code>, <code>warning</code> and <code>message</code> into a list.</p>
<pre class="r"><code>capture_log1 &lt;- function(f) {
    function(...) {
        logs &lt;- list()
        add_log &lt;- function(type, message) {
            new_l &lt;- logs
            new_log &lt;- list(timestamp = format(Sys.time(), tz = &#39;UTC&#39;, format = &#39;%Y-%m-%d %H:%M:%S&#39;),
                            type = type,
                            message =  message)
            new_l[[length(new_l) + 1]]  &lt;- new_log
            logs &lt;&lt;- new_l
        }
        res &lt;- withCallingHandlers(
            tryCatch(f(...), error=function(e) {
                add_log(&quot;error&quot;, conditionMessage(e))
                NULL
            }), warning=function(w) {
                add_log(&quot;warning&quot;, conditionMessage(w))
                invokeRestart(&quot;muffleWarning&quot;)
            }, message = function(m) {
                add_log(&quot;message&quot;, conditionMessage(m))
                invokeRestart(&quot;muffleMessage&quot;)
            })
        list(res, logs = logs)
    }

}</code></pre>
<pre class="r"><code>capture_log1(test_message)(1)</code></pre>
<pre><code>## [[1]]
## [1] 1
## 
## $logs
## $logs[[1]]
## $logs[[1]]$timestamp
## [1] &quot;2020-10-21 06:52:52&quot;
## 
## $logs[[1]]$type
## [1] &quot;message&quot;
## 
## $logs[[1]]$message
## [1] &quot;this is test from function message.\n&quot;</code></pre>
<pre class="r"><code>capture_log1(test_warning)(1)</code></pre>
<pre><code>## [[1]]
## [1] 1
## 
## $logs
## $logs[[1]]
## $logs[[1]]$timestamp
## [1] &quot;2020-10-21 06:52:52&quot;
## 
## $logs[[1]]$type
## [1] &quot;warning&quot;
## 
## $logs[[1]]$message
## [1] &quot;this is test from function warning.&quot;</code></pre>
<pre class="r"><code>capture_log1(test_error)(1)</code></pre>
<pre><code>## [[1]]
## NULL
## 
## $logs
## $logs[[1]]
## $logs[[1]]$timestamp
## [1] &quot;2020-10-21 06:52:52&quot;
## 
## $logs[[1]]$type
## [1] &quot;error&quot;
## 
## $logs[[1]]$message
## [1] &quot;this is test from function error.&quot;</code></pre>
<p>The only problem is the function cannot capture <code>print</code> and <code>cat</code>.</p>
</div>
<div id="send-logs-into-database-through-restapi-in-real-time" class="section level2">
<h2>Send logs into database through restAPI in real time</h2>
<p>In the next step, I would like to POST logs into batabase through restAPI in real time, but
not too frequent to reduce overhead of web server (e.g. 10s as minimum time interval). In this case, all unsent logs generated by R function are cached in the memory until next POST time. However, unsent logs might be lost if the function is finished before the next POST time. A special final log, which starts with a random string (e.g. GtBRVWpNGunZRJAt), can be used to POST all unsent logs. All unsent logs are also required to POST into dataset when an <code>error</code> is happening.</p>
<pre class="r"><code>post_log &lt;- function(id, data) {
  # post to restAPI here
  # ...
}
#&#39; Capture log and post by restAPI
#&#39;
#&#39; @param f A function
#&#39; @param id The id to POST to restAPI
#&#39; @param post Whether to post message
#&#39;
#&#39; @return A list with result of function f and all logs
#&#39; @export
capture_log2 &lt;- function(f, id, post = FALSE) {
    function(...) {
        logs &lt;- list()
        remain_logs &lt;- list()
        post_time &lt;- NULL
        add_log &lt;- function(type, message) {
            new_l &lt;- logs
            # Only post message if the time interval is more than 10 s
            # and contain the last message key (GtBRVWpNGunZRJAt)
            # and type equals to stop
            is_post &lt;- FALSE
            if (is.null(post_time)) {
                is_post &lt;- TRUE
            } else {
                time_interval &lt;- as.numeric(Sys.time()) - as.numeric(post_time)
                if (type == &#39;error&#39; |
                    time_interval &gt; 10) {
                    is_post &lt;- TRUE
                }
            }
            if (grepl(&quot;^GtBRVWpNGunZRJAt:&quot;, message)) {
                is_post &lt;- TRUE
                message &lt;- gsub(&quot;^GtBRVWpNGunZRJAt:(.*)&quot;, &#39;\\1&#39;, message)
            }
            new_log &lt;- list(id = id,
                            timestamp = format(Sys.time(), tz = &#39;UTC&#39;, format = &#39;%Y-%m-%d %H:%M:%S&#39;),
                            type = type,
                            message =  message)
            if (post) {
                tryCatch({

                    new_remain_logs &lt;- remain_logs
                    new_remain_logs[[length(new_remain_logs) + 1]]  &lt;- new_log

                    if (is_post) {
                        # Function to post logs through restAPI
                        post_log(id = id,
                                    data = new_remain_logs)
                        remain_logs &lt;&lt;- list()
                        post_time &lt;&lt;- Sys.time()
                    } else {
                        remain_logs &lt;&lt;- new_remain_logs
                    }
                }, error = function(e) {
                    print(e)
                })
            }
            new_l[[length(new_l) + 1]]  &lt;- new_log
            logs &lt;&lt;- new_l
        }
        res &lt;- withCallingHandlers(
            tryCatch(f(...), error=function(e) {
                add_log(&quot;error&quot;, conditionMessage(e))
                NULL
            }), warning=function(w) {
                add_log(&quot;warning&quot;, conditionMessage(w))
                invokeRestart(&quot;muffleWarning&quot;)
            }, message = function(m) {
                add_log(&quot;message&quot;, conditionMessage(m))
                invokeRestart(&quot;muffleMessage&quot;)
            })
        list(res, logs = logs)
    }

}</code></pre>
<pre class="r"><code>test_final_message &lt;- function(a) {
    message(&#39;GtBRVWpNGunZRJAt:This is a final message&#39;)
}</code></pre>
<pre class="r"><code>capture_log2(test_message, 1, post = TRUE)(1)
capture_log2(test_warning, 1, post = TRUE)(1)
capture_log2(test_error, 1, post = TRUE)(1)
capture_log2(test_final_message, 1, post = TRUE)(1)</code></pre>
</div>
